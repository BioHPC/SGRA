import org.apache.spark.SparkContext
import org.apache.spark.SparkContext._
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD
import org.apache.spark.SparkConf
import scala.collection.mutable.ArrayBuffer

object CompositeEdgeContraction {

  val usage = """
    Usage: CompositeEdgeContraction filename
  """

  def main(args: Array[String]) {

    if (args.length == 0) {
      println(usage)
      System.exit(1)
    }

    // if debug = 0, just print the final output
    // if debug = 1, print all intermediate results
    val debug = 0

    // We pass the SparkContext constructor a SparkConf object which contains 
    // information about our application
    val conf = new SparkConf().setAppName("Composite Edge Contraction Application")
    // Initialize a SparkContext as part of the program
    val sc = new SparkContext(conf)

    // Intialize edgeListFile
    // val edgeListFile = "data/test05_edge_list.txt"
    val edgeListFile = args(0)

    // Load edge list into graph
    val edges = sc.textFile(edgeListFile).flatMap { line =>
      if (!line.isEmpty && line(0) != '#') {
        val lineArray = line.split("\\s+")
        if (lineArray.length < 2) {
          None
        } else {
          val srcId = lineArray(0).toLong
          val dstId = lineArray(1).toLong
          val attr  = lineArray(2)
          val atAr  = attr.split(",")
          // edge has 9 attributes Ex) 3,F,33,0,0,2,34,0,32
          // Col1: overlap orientation
          // 0 = u<--------<v      reverse of u to reverse of v  
          //   => This case is handled in DOT file preprocessing step and changed to 3 (u>-->v)
          // 1 = u<-------->v      reverse of u to forward of v
          // 2 = u>--------<v      forward of u to reverse of v
          // 3 = u>-------->v      forward of u to forware of v
          // Col2: overlap property F:forward, 
          //                        FRC::read1 overlaps with the reverse complement of read2
          // Col3~9: overlap length, substitutions, edits, start1, stop1, start2, stop2
          Some(Edge(srcId, dstId, (atAr(0).toInt,atAr(1),atAr(2).toLong,
                                   atAr(3).toLong,atAr(4).toLong,atAr(5).toLong,
                                   atAr(6).toLong,atAr(7).toLong,atAr(8).toLong)))
        }
      } else {
        None
      }
    }

    // construct graph from edges
    val graph = Graph.fromEdges(edges, 1)

    // start composite edge contraction
    println(s"====================================================")
    println(s"Composite edge contraction started!")
    println(s"Number of edges for the input graph: ${graph.edges.count()}")
    println(s"")

    // debug
    if (debug > 0) {
      // print vertices and edges
      println(s"====================================================")
      println(s"Graph vertices:")
      graph.vertices.collect.foreach(println(_))
      println(s"====================================================")
      println(s"Graph edges:")
      graph.edges.collect.foreach(println(_))

      // the Edge class has srcId, dstId, attr members
      println(s"====================================================")
      println(s"Graph edges orientation info:")
      for (e <- graph.edges.collect) {
        println(s"${e.srcId} --> ${e.dstId} has ${e.attr._1} edge orientation")
      }
    }

    // in and out degree count and save to readOriDeg (read orientation degree into in(Int), out(Int))
    val readOriDeg: VertexRDD[(Int,Int,Long,Long)] = graph.mapReduceTriplets[(Int,Int,Long,Long)](
      // map function: for each edge send a message to the src and dst vertices with the edge attribute
      triplet => {
        // 1 = u<-------->v      reverse of u to forward of v
        if (triplet.attr._1 == 1) {       
          Iterator((triplet.srcId, (1,0,triplet.srcId,-1)), (triplet.dstId, (1,0,triplet.srcId,-1)))
        }
        else if (triplet.attr._1 == 2) {  // 2 = u>--------<v      forward of u to reverse of v
          Iterator((triplet.srcId, (0,1,-1,triplet.dstId)), (triplet.dstId, (0,1,-1,triplet.dstId)))
        }
        else if (triplet.attr._1 == 3) {  // 3 = u>-------->v      forward of u to forware of v
          Iterator((triplet.srcId, (0,1,-1,triplet.dstId)), (triplet.dstId, (1,0,triplet.srcId,-1)))
        }
        else {
          Iterator.empty
        }
      },
      // reduce
      // to save in degree vertex id and out degree vertex id, we should consider below cases.
      (a, b) => if ((a._3 != -1) && (a._4 == -1)) {
                  (a._1+b._1, a._2+b._2, a._3, b._4)
                }
                else if ((a._3 == -1) && (a._4 != -1)) {
                  (a._1+b._1, a._2+b._2, b._3, a._4)
                }
                else {
                  (a._1+b._1, a._2+b._2, b._3, b._4)
                }

    )

    // debug
    if (debug > 0) {
      println(s"====================================================")
      println(s"readOriDeg VertexRDD generated:")
      readOriDeg.collect.foreach(println(_))

      // check one in and one out degree vertices
      println(s"====================================================")
      println(s"Check who has one in and one out degree:")
      readOriDeg.filter {
        case (id, attr) => (attr._1 == 1 && attr._2 == 1)
      }.collect.foreach {
        case (id, attr) => println(s"Vertex ${id} has one in and out degree with properties: ${attr}")
      }
    }


    // one in and one out RDD
    var oneInOutRDD = readOriDeg.filter {
      case (id, attr) => (attr._1 == 1 && attr._2 == 1)
    }.cache()

    // debug
    if (debug > 0) {
      println(s"====================================================")
      println(s"oneInOutRDD VertexRDD generated:")
      oneInOutRDD.collect.foreach(println(_))
    }

    // loop until activeJob exist. Terminamte if the loop meets maxIterations
    // Example>
    // vertexId,(inDegree, outDegree, inVertexId, outVertexId)
    // 2(1,1,0,4) --> should be 2(1,1,0,6)
    // 4(1,1,2,6) --> should be 4(1,1,0,6)
    // Loop1: 2(1,1,0,4) and 2(1,1,0,4):
    // Loop2: 2(1,1,0,4) and 4(1,1,2,6): If 1.outVertexId == 2.vertexId, then update 1.outVertexId to be 2.outVertexId
    // Loop3: 4(1,1,2,6) and 2(1,1,0,4): If 1.inVertexId == 2.vertexId, then update 1.inVertexId to be 2.inVertexId
    // Loop4: 2(1,1,0,4) and 4(1,1,2,6): 

    // initialize variables for loop
    var countIterations : Long = 0
    var maxIterations : Long = 10
    var activeJob : Long = 1

    // loop
    while (activeJob > 0 && countIterations < maxIterations) {
      // initialize activeJob
      activeJob = 0

      // mutable scala arrays
      var updatedOneInOutArrayBuffer = ArrayBuffer.empty[(Long, (Int, Int, Long, Long))]

      // pairwise comparison
      oneInOutRDD.collect.foreach {
        case (id1, attr1) => 
        // pairwise comparison
        oneInOutRDD.collect.foreach {
          case (id2, attr2) => {
            // If 1.outVertexId == 2.vertexId, then update 1.outVertexId to be 2.outVertexId
            if (attr1._4 == id2) {
              // append to updatedOneInOutArrayBuffer
              updatedOneInOutArrayBuffer ++= ArrayBuffer((id1, (1, 1, attr1._3, attr2._4)))
              activeJob += 1
            }
            // If 1.inVertexId == 2.vertexId, then update 1.inVertexId to be 2.inVertexId
            else if (attr1._3 == id2) {
              // append to updatedOneInOutArrayBuffer
              updatedOneInOutArrayBuffer ++= ArrayBuffer((id1, (1, 1, attr2._3, attr1._4)))
              activeJob += 1
            }
          }
        }
      }

      // convert ArrayBuffer to Array
      var updatedOneInOutArray = updatedOneInOutArrayBuffer.toArray

      // convert Array to VertexRDD
      var updatedOneInOutRDD: RDD[(VertexId, (Int, Int, Long, Long))] =  sc.parallelize(updatedOneInOutArray)

      // print RDD
      // updatedOneInOutRDD.collect.foreach(println(_))

      // ontInOutRdd values should be transformed using updatedOneInOutRDD without changing the ids
      var newOneInOutRDD: VertexRDD[(Int,Int,Long,Long)] = oneInOutRDD.leftJoin(updatedOneInOutRDD) {
        (id, attr, comp) => comp.getOrElse(attr)
      }

      // allocate newOneInOutRDD to oneInOutRDD and loop again
      oneInOutRDD = newOneInOutRDD

      // add countIterations
      countIterations += 1
    }

    // debug
    if (debug > 0) {
      println(s"====================================================")
      println(s"Loop search to update fromVertexId and toVertexId for composite edges")
      println(s"countIterations=${countIterations}")
      println(s"====================================================")
      // print
      println(s"oneInOutRDD:")
      oneInOutRDD.collect.foreach(println(_))
    }

    // create initial read graph
    val initialReadGraph: Graph[(Int,Int,Long,Long),(Int, String, Long, Long, Long, Long, 
      Long, Long, Long)] = graph.mapVertices{ case (id,weight) => (0,0,-1,-1) }

    // Merge the new vertex values into the readGraph
    //val readGraph = initialReadGraph.outerJoinVertices(readOriDeg) {
    val readGraph = initialReadGraph.outerJoinVertices(oneInOutRDD) {
      (vid, old, newOpt) => newOpt.getOrElse(old)
    }

    // debug
    if (debug > 0) {
      // check the graph
      println(s"====================================================")
      println(s"readGraph was generated:}")
      readGraph.vertices.collect.foreach(println(_))
      readGraph.edges.collect.foreach(println(_))
    }

    // debug
    if (debug > 0) {
      // check one in and one out degree vertices
      println(s"====================================================")
      println(s"Check one in and one out degree of readGraph:}")
      readGraph.vertices.filter {
        case (id, attr) => (attr._1 == 1 && attr._2 == 1)
      }.collect.foreach {
        case (id, attr) => println(s"Vertex ${id} has one in degee and one out degree")
      }
    }

    // delete composite edges and related nodes
    val delOneInOutReadGraph = readGraph.subgraph(vpred = (id, attr) => attr._1 != 1 || attr._2 != 1)

    // debug
    if (debug > 0) {
      // check one in and one out degree vertices
      println(s"====================================================")
      println(s"Delete one in and out vertices and edges}")
      println(s"delOneInOutReadGraph was generated:}")
      delOneInOutReadGraph.vertices.collect.foreach(println(_))
      delOneInOutReadGraph.edges.collect.foreach(println(_))
    }

    // Merge the composite edges------------------------------------------------------
    // Later (after we fix the edge properties structure), this step should be updated 
    // to have correct properties.

    // mutable scala arrays
    var newEdgesArrayBuffer = ArrayBuffer.empty[Edge[(Int,String,Long,Long,Long,Long,Long,Long,Long)]]
    // Example> newEdgesArrayBuffer ++= ArrayBuffer(Edge(1L,2L,(3,"F",1L,1L,1L,1L,1L,1L,1L)))

    // new edges are appended to ArrayBuffer
    readGraph.vertices.collect.foreach{
      case (id, attr) => {
        if (attr._1 == 1 && attr._2 == 1) {
          newEdgesArrayBuffer ++= ArrayBuffer(Edge(attr._3,attr._4,(3,"F",1L,1L,1L,1L,1L,1L,1L)))
        }
      }
    }

    delOneInOutReadGraph.edges.collect.foreach{
      case (Edge(id1, id2, attr)) => {
        newEdgesArrayBuffer ++= ArrayBuffer(Edge(id1,id2,attr))
      }
    }

    // convert ArrayBuffer to Array
    val newEdgesArray = newEdgesArrayBuffer.toArray

    // only get unique values
    val newUniqueEdgesArray = newEdgesArray.distinct

    // convert Array to EdgeRDD
    val newEdgesRDD: RDD[Edge[(Int, String, Long, Long, Long, Long, Long, Long, Long)]] =  sc.parallelize(newUniqueEdgesArray)

    // new vertices RDD
    val newVerticesRDD: RDD[(VertexId, (Int, Int, Long, Long))]=delOneInOutReadGraph.vertices

    // new graph
    val newGraph: Graph[(Int, Int, Long, Long), (Int, String, Long, Long, Long, Long, Long, Long, Long)]= Graph(newVerticesRDD, newEdgesRDD)

    // debug
    if (debug > 0) {
      // check one in and one out degree vertices
      println(s"====================================================")
      println(s"Delete one in and out vertices and edges}")
      println(s"newGraph was generated:}")
      newGraph.vertices.collect.foreach(println(_))
      newGraph.edges.collect.foreach(println(_))
    }

    // end composite edge contraction
    println(s"====================================================")
    println(s"Composite edge contraction done!")
    println(s"Number of edges for final graph: ${newGraph.edges.count()}")
    println(s"")
  }
}
